/*
	et-tiltnloo.cc
	Prepare data for even/odd FSC analysis
	Author: Giovanni Cardone
	Created: 20050318 	Modified: 20050329
*/

#include "bsoft.h"
#include "tilt.h"
#include "resol.h"
#include "nloo2d.h"

// Usage assistance
char* use[] = {
" ",
"Usage: et-tiltnloo [options] input.file output.file ",
"------------------------------------------------------------------",
"Calculate the resolution as a function of the tilt angle.",
"It accepts as input the file generated by the option '-nloo2d' given in et-nloo.",
"Averages, if related flags are set, are weighted by the given tilt spacing."
" ",
"Parameters:",
"-verbose 7               Verbosity of output",
"-cavg 5                  Number of NLOO2D curves to average for the resolution estimate (default 3)", 
"-ravg 3                  Number of resolution estimates to average (default 1)", 
"-threshold 0.3,0.5,0.7   Thresholds at which resolution is evaluated (up to three values, default 0.3,0.5)",
"-resolution 15           Resolution limit for analysis",
" ",
"Output:",
"-intermediate            save to file the intermediate files (i.e. the averaged curves: to use along",
"                         with the option -cavg)",
" ",
NULL
};

int 		main(int argc, char **argv)
{

	// Initialize variables
	
	char*		in_file = NULL;				// input filename
	char*		out_file = NULL;				// output filename
	
	int			ntlt_angs = 0;				// number of tilt angles
	
	float		res_thr[RES_NTHRESHOLDS] = {0.3, 0.5, 0.};
	int			nrt = 2;						// number of resolution thresholds
	float		res = 0.;					// resolution limit
	float*		res_est = NULL;
	float*		res_est_avg = NULL;

	int			ncavg = 3;					// number of curves to average 
	int			nravg = 1;					// number of estimates to average 
	int			intermediate = 0;			// intermediate files flag
	
	float 		deltat, t0, wsum, ires, ires_1, jratio;
	float*		wght = NULL;	
	float*		rwght = NULL;	
	int			i, ii, j, jp, jfirst, jlast, nj, jj, jin, min, mout;
	int			np, nn, s;
	int			optind;

	Option*		option = get_option_list(use, argc, argv, &optind);
	Option*		curropt;
	for ( curropt = option; curropt; curropt = curropt->next ) {
 		if ( strcmp(curropt->tag, "intermediate") == 0 )
			intermediate = 1;
 		if ( strcmp(curropt->tag, "threshold") == 0 )
			if ( (nrt = sscanf(curropt->value, "%f,%f,%f",&res_thr[0],&res_thr[1],&res_thr[2])) < 1 )
				fprintf(stderr, "-threshold: a list of maximum three thresholds must be specified");
 		if ( strcmp(curropt->tag, "cavg") == 0 )
			if ( sscanf(curropt->value, "%d", &ncavg) < 1 )
				fprintf(stderr, "-cavg: a number of curves to average must be specified");
 		if ( strcmp(curropt->tag, "ravg") == 0 )
			if ( sscanf(curropt->value, "%d", &nravg) < 1 )
				fprintf(stderr, "-ravg: a number of resolution estimates to average must be specified");
 		if ( strcmp(curropt->tag, "resolution") == 0 )
			if ( sscanf(curropt->value, "%f", &res) < 1 )
				fprintf(stderr, "-resolution: A resolution must be specified!\n");
    }
	option_kill(option);

	if ( verbose ) {
		printf("\n-----------------------------------------------\n");
		printf("                   et-tiltnloo\n");
		printf("  Calculate the resolution versus the tilt angle\n");
		printf("-----------------------------------------------\n\n");
	}

	// check if given input files
	if ( optind > argc - 2 ) {
		fprintf(stderr, "Error: two input files needed!\n");
		exit(-1);
	}
	else {
		in_file = copystring(argv[optind++]);
		out_file = copystring(argv[optind]);
	}

	// initializations

	if ( ncavg< 1 ) ncavg = 1;
	ncavg = (ncavg/2)*2 + 1;  // force to odd value

	if ( nravg< 1 ) nravg = 1;
	nravg = (nravg/2)*2 + 1;  // force to odd value
	
	wght = (float *) balloc(ncavg*sizeof(float));
	rwght = (float *) balloc(nravg*sizeof(float));
	
	N2d_curve* n2dc = NULL;
	if ( (n2dc = n2d_read_file(in_file)) == NULL) exit(-1);

	if ( verbose & VERB_PROCESS )
		printf("Read %d curves, each of size %d\n", n2dc->nc, n2dc->ns);

	N2d_curve* n2dc_avg = n2d_init(n2dc->nc, n2dc->ns);
	for ( s = 0; s < n2dc->ns; s++) n2dc_avg->axis[s] = n2dc->axis[s];
	for ( s = 0; s < n2dc->ns; s++) n2dc_avg->res[s] = n2dc->res[s];
	
	
	ntlt_angs = n2dc->nc;
	np = ntlt_angs;

	res_est = (float *) balloc(np*RES_NTHRESHOLDS*sizeof(float));
	
	// calculate averaged curves
	for ( jp = 0; jp < np; jp++) {

		jratio = 1.;
		jfirst = jp - ncavg/2;
		if ( jfirst < 0 ) {
			jratio = -(ncavg-1.) / jfirst;	
			jfirst =0;
		}
		
		jlast = jp + ncavg/2;
		if ( jlast > np-1 ) {
			jratio = (ncavg-1.) / (jlast - np+1);	
			jlast = np - 1;
		}
		
		nj = jlast - jfirst + 1;

		// determine weights
		if (nj>1) deltat = jratio*fabs(n2dc->tlt_angs[jlast]-n2dc->tlt_angs[jfirst]);
		else deltat = 1.;
		
		t0 = n2dc->tlt_angs[jp];
		wsum = 0.;
		
		for ( jj = 0; jj < nj; jj++) {
			wght[jj] = deltat - fabs(n2dc->tlt_angs[jfirst+jj] - t0);
			wsum += wght[jj];
		}
		for ( jj = 0; jj < nj; jj++)	wght[jj] /= wsum;
		

		// perform weighted average
		for ( jj = 0; jj < nj; jj++) {
			for (int s = 0; s < n2dc->ns; s++) {
				mout = jp*n2dc->ns + s;
				min = (jfirst+jj)*n2dc->ns + s;
				n2dc_avg->data[mout] += wght[jj]*n2dc->data[min];
			}
		}

	}

	// estimate angular resolution
	for ( j = 0; j < np; j++) {
		nn =j*RES_NTHRESHOLDS;
		ires_1 = 1./n2dc->res[0];
		for ( s = 1; s < n2dc->ns; s++) {
			if ( n2dc->res[s] < res) break;
			ires = 1./n2dc->res[s];
			i = j*n2dc->ns + s;
			for ( ii = 0; ii<nrt; ii++) {
				if ( n2dc_avg->data[i-1] >= res_thr[ii] && n2dc_avg->data[i] < res_thr[ii] )
					res_est[nn+ii] = ires + 
					  (ires_1 - ires)*(res_thr[ii] - n2dc_avg->data[i])/
					    (n2dc_avg->data[i-1] - n2dc_avg->data[i]);
			}
			ires_1 = ires;
		}
		for ( ii = 0; ii<nrt; ii++)
			if ( res_est[nn+ii] > SMALLFLOAT ) res_est[nn+ii] = 1./res_est[nn+ii];
	}

	// calculate average over estimates
	if (nravg > 1 ) {
		res_est_avg = (float *) balloc(np*RES_NTHRESHOLDS*sizeof(float));
		for ( jp = 0; jp < np; jp++) {
			nn =jp*RES_NTHRESHOLDS;

			jratio = 1.;
			jfirst = jp - nravg/2;
			if ( jfirst < 0 ) {
				jratio = -(nravg-1.) / jfirst;	
				jfirst =0;
			}
		
			jlast = jp + nravg/2;
			if ( jlast > np-1 ) {
				jratio = (nravg-1.) / (jlast - np+1);	
				jlast = np - 1;
			}
		
			nj = jlast - jfirst + 1;

			// determine weights
			if (nj>1) deltat = jratio*fabs(n2dc->tlt_angs[jlast]-n2dc->tlt_angs[jfirst]);
			else deltat = 1.;
		
			t0 = n2dc->tlt_angs[jp];
			wsum = 0.;
		
			for ( jj = 0; jj < nj; jj++) {
				rwght[jj] = deltat - fabs(n2dc->tlt_angs[jfirst+jj] - t0);
				wsum += rwght[jj];
			}
			for ( jj = 0; jj < nj; jj++)	rwght[jj] /= wsum;
		

			// perform weighted average
			for ( jj = 0; jj < nj; jj++) {
				jin = (jfirst+jj)*RES_NTHRESHOLDS;
				for ( ii = 0; ii<nrt; ii++) {
					res_est_avg[nn+ii] += rwght[jj]*res_est[jin+ii];
				}
			}
		}
		bfree(res_est,np*RES_NTHRESHOLDS*sizeof(float));
		res_est = res_est_avg;
	}

	// save resolution estimates to file
	FILE* fdout = fopen(out_file,"w");
	fprintf(fdout,"n\ttheta");
	for (i = 0; i<nrt; i++)
		fprintf(fdout,"\tNLOO2D(%3.1f)",res_thr[i]);
	fprintf(fdout,"\n");

	for ( j = 0; j < np; j++) {
		nn =j*RES_NTHRESHOLDS;
		fprintf(fdout,"%d\t%5.2f",j+1, n2dc->tlt_angs[j]);
		for ( i = 0; i<nrt; i++)
			fprintf(fdout,"\t%8.3f",res_est[nn+i]);
		fprintf(fdout,"\n");
	}
	fclose(fdout);

	// save intermediate data (averaged curves)
	if (intermediate){
		FILE * 	fpt	= fopen(insert_in_filename(in_file,"avg",'_'), "w");
		for ( j = 0; j < np; j++) {
			nn = j*n2dc->ns;
			fprintf(fpt,"Projection # %d - Tilt angle: %5.2f\n",j+1,n2dc->tlt_angs[j]);
			fprintf(fpt,"Radius\ts(1/A)\tRes(A)\tNLOO2D\n"); 
			for ( i=0; i<n2dc->ns; i++ ) {
				fprintf(fpt,"%d\t%7.5f\t%9.3f\t%8.4f\n",  
						i, n2dc->axis[i], n2dc->res[i], n2dc_avg->data[nn+i]);
			}
		}
		fclose(fpt);
	}

	bfree(res_est,np*RES_NTHRESHOLDS*sizeof(float));
	bfree(rwght,nravg*sizeof(float));
	bfree(wght,ncavg*sizeof(float));
	bfree_string(in_file);
	bfree_string(out_file);

	n2d_kill(n2dc_avg);
	n2d_kill(n2dc);
	
	if ( verbose ) {
		printf("-----------------------------------------------\n");
		printf("      et-tiltnloo concluded successfully!\n");
		printf("-----------------------------------------------\n");
	}
	return(0);
}

