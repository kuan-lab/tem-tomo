/*
	et-nloo.cc
	Estimate resolution by Noise-compensated Leave-One-Out (NLOO) method
	Author: Giovanni Cardone
	Created: 20050123	Modified: 20070709
*/

#include "bsoft.h"
#include "string_tools.h"
#include "proj.h"
#include "shape.h"
#include "tilt.h"
#include "ioroutines.h"
#include "imod.h"
#include "resol.h"

// Usage assistance
char* use[] = {
" ",
"Usage: et-nloo [options] [output_prefix] ",
"---------------------------------------------------------------------------------------------------------------------------",
"Estimate the resolution of a tomogram by 3D Noise-compensated Leave-One-Out analysis.",
" ",
"Mandatory inputs to the program are the reconstructed map, the input projections,",
"the two different reprojections from the map, and the tilt angles. These values can be",
"given directly, by using the different option flags, or indirectly, by specifying the",
"imod parameter file used to generate the tomogram. In this last case the input data",
"are assumed to have been generated by means of et-nloo_setup.", 
" ",
"Output notation: if a prefix for the output files is not specified, then the",
"                 prefix is derived from the map file name. A proper string is",
"                 attached to any of the resolution curves chosen as output.",
"NOTE: if the options box, sphere, maxsphere, ibox, isphere and undersamp have been set for et-nloo_setup,",
"      they must be set here exactly in the same way.",
" ",
"Actions:",
"-taper                   Apply tapering function to borders of the projection area of interest.",
"-box 1,1,1,50,50,30      Lower corner coords (first three values) and size of the resolution analysis box (pixels)",
"-sphere 100,100,100,50   Coords of center (first three values) and radius of the resolution analysis sphere (pixels)",
"-maxsphere               Resolution analysis limited to maximum centered sphere included in the volume",
"-ibox 10,10,10,25,25,25  Lower corner coords (first three values) and size of the resolution analysis inner box (pixels)",
"-isphere 50,50,50,20     Coords of center (first three values) and radius of the resolution analysis inner sphere (pixels)",
"-undersamp 5             approximate mode: undersampling factor reducing the number",
"                         of projections/reprojections considered for resolution analysis",
"                         (default: 1, i.e. no approximation)",
" ",
"Parameters:",
"-verbose 7               Verbosity of output",
"-sampling 1.5,1.5        Sampling (angstrom/pixel, a single value sets both)",
"-resolution 15           Resolution limit for output (angstrom, default is taken from the imod file, if given)",
"-threshold 0.3,0.5,0.7   Thresholds at which resolution is evaluated (up to three values, default 0.3,0.5)",
"-bin 4                   Width of annulus region in fourier space (pixels - default 2)",
"-background  frame       Region, with respect to the reprojection from the selected volume,",
"                         where calculating the background to apply:",
"                           1=frame (default, frame along the border of the projection)",
"                           2=inside (all the projected area)",
"-rescale  ls             Method for rescaling pairs of projections:",
"                           0=avgstd (default, same average and standard deviation)",
"                           1=ls (least-squares linear regression)",
" ",
"Input:",
"-map vol.map             reconstructed tomogram",
"-input_proj pinput.mrc   input projections",
"-full_reproj pfull.mrc   reprojections from tomogram",
"-miss_reproj pmiss.mrc   reprojections from partial tomograms",
"-proj_prefix hvproj.mrc  prefix file name for projection files",
"                         (to use instead of the previous three parameters, which are",
"                         so derived:",
"                         {proj_prefix}_input.mrc   masked input projections;",
"                         {proj_prefix}_full.mrc    masked reprojections from full reconstruction;",
"                         {proj_prefix}_miss.mrc    masked reprojections from partial reconstructions)",
"-tilt     series.tlt     tilt angles",
"-xtilt 2.4               Rotation around x axis by which reconstruction was rotated (degrees - default 0)",
"-exclude 1-2,45,59       list of projections excluded from reconstruction",
"-imod tilt.com           imod parameter file (alternative to all the previous inputs, except for 'proj_prefix')",
" ",
"Output:",
"-nloo3d                  NLOO3D resolution curve (filename: {output_prefix}_nloo3d_res.txt)",
"-res_tilt                Resolution versus tilt angle curves (filename: {output_prefix}_tilt_res.txt)",
"                         One of more curves are calculated with respect to the thresholds values specified",
"                         with the option -threshold",
"-nloo2d                  NLOO2D curves for each tilt angle (filename: {output_prefix}_nloo2d_res.txt)",
" ",
NULL
};

int is_inlist(int idx, int* xcld_list, int nxl);

int 		main(int argc, char **argv)
{

	// Initialize variables
	
	FILE*		fdar = NULL;					// angular resolution file descriptor 
	Vector3		sampling = {0.0,0.0,0.0};		// Sampling of projections (angstrom).",
	Vector3 		vol_origin = {0.,0.,0.}; 		// Origin coords of volume
	char*		out_pfx_file = NULL;			// output prefix filename
	char*		fullproj_file = NULL;			// projections from full reconstruction filename
	char*		refproj_file = NULL;			// masked input projections filename
	char*		missproj_file = NULL;			// projections from missing reconstruction filename
	char*		in_vol_file = NULL;			// input reconstruction filename
	char*		proj_prefix_file = NULL;		// prefix for masked projection filenames
	char*		tlt_file = NULL;				// tilt angles file
	char*		imod_parfile = NULL;			// imod parameters file
	char*		out_nloo3d_file= NULL;
	char*		out_nloo2d_file= NULL;
	char*		out_angres_file= NULL;

	Bimage*		b = NULL;				    // generic image
	Bimage*		full_vol = NULL;			// original reconstruction volume
	Bimage*		bm = NULL;					// image containing reprojection from partial reconstruction
	Bimage*		bf = NULL;					// image containing reprojection from original reconstruction
	Bimage*		br = NULL;					// image containing input projection
	Proj*		miss_proj = NULL;			// reprojection from partial reconstruction
	Proj*		full_proj = NULL;			// reprojection from original reconstruction
	Proj*		ref_proj = NULL;				// input projection

	
	Imod_tilt*   imd_tpars = NULL;			// imod tilt parameters

	Ires_nloo3d* inloo3d = NULL;			// integrated resolution

	int			nangs = 0;					// number of tilt angles
	float*		tlt_angs = NULL;			// tilt series
	int			nviews = 0;					// number of tilt views
	View*		tlt_views = NULL;			// tilt series expressed as views
	float		psi0 = 0.0;					// Euler angles
	float		theta0 = 0.0;				//   corresponding to the reference view
	float		phi0 = 0.0;					//   of the ideal planar acquisition
	View			tlt0_view =
			      {(View*) NULL, 0,0,1,0};	// Reference view of ideal planar acquisition
	float		xtilt = 0.0;					// default x tilt angle
	
	float		res = 0.;					// resolution limit
	float		res_thr[RES_NTHRESHOLDS] = {0.3, 0.5, 0.};
	int			nrt = 2;						// number of resolution thresholds
	float*		res_est;

	int			bin_size = 2;			// annulus width for resolution analysis

	int			np;						// number of projections
	int			taper = 0;				// projection tapering flag

	Shape3d*	volut = NULL;			// volume under test
	int			vol_type = VALL;		// resolution space constraint 0=all; 1=box
										// 2=sphere ; 3=maxsphere 
	int			ivol_type = VNONE;		// resolution inner space constraint 0=none;
										// 1=box ; 2=sphere 
	float		ox=-1., oy=-1., oz=-1.;
	float		sx=-1., sy=-1., sz=-1.;
	float		iox=-1., ioy=-1., ioz=-1.;
	float		isx=-1., isy=-1., isz=-1.;

	int			rescale_type = 0;		// how to normalize pairs of images:
										// 0 = avgstd = same average and standard deviation
										// 1 = ls = least-squares linear regression
	int			bground_type = SFRAME;	// how to evaluate the background:
										// 1 = frame = along a frame internal to the selected projection area
										// 2 = inside = internal to the selected projection area

	char*		xcld_str = NULL;			// exclude list string from input
	int			icheck = 0;				// input consistency check
	int			ipfx = 0;				// input prefix flag
	int			set_xtilt = 0;
	int			set_xcld = 0;
	int			nxl = 0;
	int			xcld_list[XCLDN];
	int			out_nloo3d = 0;
	int			out_nloo2d = 0;
	int			out_angres = 0;
		
	int			tusamp = 1;				// tilt series undersampling factor

	int			optind;

	Option*		option = get_option_list(use, argc, argv, &optind);
	Option*		curropt;
	for ( curropt = option; curropt; curropt = curropt->next ) {
		if ( strcmp(curropt->tag, "sampling") == 0 )
			sampling = get_option_sampling(curropt->value);
 		if ( strcmp(curropt->tag, "imod") == 0 )
			imod_parfile = get_option_filename(curropt->value);
 		if ( strcmp(curropt->tag, "box") == 0 ) {
			if ( sscanf(curropt->value, "%f,%f,%f,%f,%f,%f", &ox,&oy,&oz,&sx,&sy,&sz) < 6 )
				fprintf(stderr, "-box: lower corner and size (6 values) must be specified");
		    else if (vol_type != VALL)
				fprintf(stderr, "Error: selection of only one type of volume allowed!");
		    else vol_type = VBOX;
 		}
 		if ( strcmp(curropt->tag, "sphere") == 0 ) {
			if ( sscanf(curropt->value, "%f,%f,%f,%f", &ox,&oy,&oz,&sx) < 4 )
				fprintf(stderr, "-sphere: center and radius (4 values) must be specified");
		    else if (vol_type != VALL)
				fprintf(stderr, "Error: selection of only one type of volume allowed!");
		    else vol_type = VSPHERE;
 		}
 		if ( strcmp(curropt->tag, "maxsphere") == 0 ) {
		    if (vol_type != VALL)
				fprintf(stderr, "Error: selection of only one type of volume allowed!");
		    else vol_type = VMAXSPHERE;
 		}
 		if ( strcmp(curropt->tag, "ibox") == 0 ) {
			if ( sscanf(curropt->value, "%f,%f,%f,%f,%f,%f", &iox,&ioy,&ioz,&isx,&isy,&isz) < 6 )
				fprintf(stderr, "-ibox: lower corner and size (6 values) must be specified");
		    else if (ivol_type != VNONE)
				fprintf(stderr, "Error: selection of only one type of inner volume allowed!");
		    else ivol_type = VBOX;
 		}
 		if ( strcmp(curropt->tag, "isphere") == 0 ) {
			if ( sscanf(curropt->value, "%f,%f,%f,%f", &iox,&ioy,&ioz,&isx) < 1 )
				fprintf(stderr, "-isphere: center and radius (4 values) must be specified");
		    else if (ivol_type != VNONE)
				fprintf(stderr, "Error: selection of only one type of inner volume allowed!");
		    else ivol_type = VSPHERE;
 		}
 		if ( strcmp(curropt->tag, "taper") == 0 ) {
       	    taper = 1;
		}
		if ( strcmp(curropt->tag, "background") == 0 ) {
			if ( sscanf(curropt->value, "%d", &bground_type) < 1 ) {
				for ( int i=0; i<(int)strlen(curropt->value); i++ )
					curropt->value[i] = tolower(curropt->value[i]);
				if ( curropt->value[0] == 'f' ) {
					bground_type = SFRAME;
				} else if ( curropt->value[0] == 'i' ) {
					bground_type =SINSIDE;
				}
			}
			if ( bground_type < 1 || bground_type > 2 ) bground_type = SFRAME;
		}
 		if ( strcmp(curropt->tag, "resolution") == 0 )
			if ( sscanf(curropt->value, "%f", &res) < 1 )
				fprintf(stderr, "-resolution: A resolution must be specified!\n");
		if ( strcmp(curropt->tag, "bin") == 0 )
			if ( sscanf(curropt->value, "%d", &bin_size) < 1 )
				fprintf(stderr, "-bin: a bin size must be specified");
 		if ( strcmp(curropt->tag, "map") == 0 ) {
			in_vol_file = get_option_filename(curropt->value);
 			icheck++;
 		}	
 		if ( strcmp(curropt->tag, "input_proj") == 0 ) {
			refproj_file = get_option_filename(curropt->value);
 			icheck++;
 		}	
 		if ( strcmp(curropt->tag, "full_reproj") == 0 ) {
			fullproj_file = get_option_filename(curropt->value);
 			icheck++;
 		}	
 		if ( strcmp(curropt->tag, "miss_reproj") == 0 ) {
			missproj_file = get_option_filename(curropt->value);
 			icheck++;
 		}
  		if ( strcmp(curropt->tag, "proj_prefix") == 0 ) {
			proj_prefix_file = get_option_filename(curropt->value);
 			icheck+=3;
 			ipfx = 1;
 		}	
 		if ( strcmp(curropt->tag, "tilt") == 0 ) {
			tlt_file = get_option_filename(curropt->value);
 			icheck++;
 		}
 		if ( strcmp(curropt->tag, "xtilt") == 0 )
			if ( sscanf(curropt->value, "%f", &xtilt) < 1 )
				fprintf(stderr, "-xtilt: a rotation around x must be specified");
 			else
 				set_xtilt = 1;
 		if ( strcmp(curropt->tag, "exclude") == 0 )
			if ( (xcld_str = copystring(curropt->value)) == NULL )
				fprintf(stderr, "-exclude: a list of values must be specified");
 			else
 				set_xcld = 1;
 		if ( strcmp(curropt->tag, "threshold") == 0 )
			if ( (nrt = sscanf(curropt->value, "%f,%f,%f",&res_thr[0],&res_thr[1],&res_thr[2])) < 1 )
				fprintf(stderr, "-threshold: a list of maximum three thresholds must be specified");
 		if ( strcmp(curropt->tag, "nloo3d") == 0 ) {
       	    out_nloo3d = 1;
		}
 		if ( strcmp(curropt->tag, "nloo2d") == 0 ) {
       	    out_nloo2d = 1;
		}
 		if ( strcmp(curropt->tag, "res_tilt") == 0 ) {
       	    out_angres = 1;
		}
 		if ( strcmp(curropt->tag, "rescale") == 0 ) {
			if ( sscanf(curropt->value, "%d", &rescale_type) < 1 ) {
				for ( int i=0; i<(int)strlen(curropt->value); i++ )
					curropt->value[i] = tolower(curropt->value[i]);
				if ( curropt->value[0] == 'a' ) {
					rescale_type = 0;
				} else if ( curropt->value[0] == 'l' ) {
					rescale_type = 1;
				} else {
					if ( rescale_type < 0 || rescale_type > 1 ) rescale_type = 0;
				}
			}
		}
 		if ( strcmp(curropt->tag, "undersamp") == 0 )
			if ( sscanf(curropt->value, "%d", &tusamp) < 1 )
				fprintf(stderr, "-undersamp: an undersampling factor must be specified");
     }
     
	option_kill(option);

	if ( optind < argc ) out_pfx_file = copystring(argv[optind]);

	if ( verbose ) {
		printf("-----------------------------------------------------\n");
		printf("                      et-nloo\n");
		printf(" Noise-compensated Leave-One-Out resolution analysis\n");
		printf("-----------------------------------------------------\n");
	}

	if ( ! (out_nloo3d || out_nloo2d || out_angres ) )
		fprintf(stderr, "Warning: no output selection! Results will not be saved to any file!\n");
	
	// check if selected imod
	if ( imod_parfile == NULL && icheck!=5) {
		fprintf(stderr, "ERROR: some mandatory input parameters missing or being duplicated!\n");
		fprintf(stderr, "Combination #1 of parameters needed: map, input_proj, full_reproj, miss_reproj, tilt.\n");
		fprintf(stderr, "Combination #2 of parameters needed: map, proj_prefix, tilt.\n");
		exit(-1);
	} else if (imod_parfile != NULL && (icheck-ipfx*3)>0 ) {
		fprintf(stderr, "ERROR: some input parameters are overlapping with those read from imod file!\n");
		fprintf(stderr, "Parameters read from imod file: map, input_proj, full_reproj, miss_reproj, tilt, xtilt, exclude\n");
		exit(-1);
	} else if (imod_parfile != NULL && ( set_xtilt || set_xcld) ) {
		fprintf(stderr, "ERROR: given parameters overlapping with those read from imod file:");
		if ( set_xtilt ) fprintf(stderr, "   xtilt   ");
		if ( set_xcld ) fprintf(stderr, "   exclude   ");
		fprintf(stderr, "\n");
		exit(-1);
	}		
	
/////////////////////////////////////////////////
//		initialization
/////////////////////////////////////////////////

	for (int i = nrt; i<RES_NTHRESHOLDS; i++) res_thr[i]=0.;
	
	if ( imod_parfile ) {
		if ( verbose & VERB_PROCESS )
			printf("Reading imod parameter file %s\n",imod_parfile);

		imd_tpars = imd_tilt_read(imod_parfile);
		if ( imd_tpars == NULL ) exit(-1);
		imd_tilt_checkvol(imd_tpars);

		// get all the parameters needed
		if ( !ipfx ) proj_prefix_file = imd_tilt_getprojfile(imd_tpars);
		in_vol_file = catenate2strings(imd_tilt_getvolfile(imd_tpars),":mrc");
		tlt_file = imd_tilt_gettiltfile(imd_tpars);
		xtilt = imd_tilt_getxtilt(imd_tpars);
		imd_tilt_copyxcldlist(xcld_list, &nxl, imd_tpars);
		
	} else {
		nxl = str_get_list(xcld_list, XCLDN, xcld_str);
	}

	// initialize input and output file names
	if ( proj_prefix_file ) {
		if (extension(proj_prefix_file))
			proj_prefix_file = copystring(filename_change_type(proj_prefix_file,"mrc")); 
		else 
			proj_prefix_file = catenate2strings(proj_prefix_file, ".mrc"); 
		missproj_file = insert_in_filename(proj_prefix_file,"miss",'_');	
		fullproj_file = insert_in_filename(proj_prefix_file,"full",'_');
		refproj_file = insert_in_filename(proj_prefix_file,"input",'_');
	}

	if (out_pfx_file == NULL)
		out_pfx_file = filename_base(in_vol_file);

	if ( out_nloo3d )
		out_nloo3d_file = insert_in_filename(filename_change_type(out_pfx_file,"txt"),"nloo3d_res",'_');	
	if ( out_angres )
		out_angres_file = insert_in_filename(filename_change_type(out_pfx_file,"txt"),"tilt_res",'_');	
	if ( out_nloo2d ) {
		out_nloo2d_file = insert_in_filename(filename_change_type(out_pfx_file,"txt"),"nloo2d_res",'_');	
		if ( ext_file_exist(out_nloo2d_file) )
			remove(out_nloo2d_file);
	}

	// volume under resolution analysis	
	full_vol = io_read_image(in_vol_file, 0, -1);

	//adjust header
	if ((imod_parfile && !imd_tilt_isparallel(imd_tpars)) ||
		(strcmp(extension(in_vol_file),"mrc")==0 && 
		(full_vol->x!=full_vol->y && full_vol->x==full_vol->z))	
	) {
		if (verbose)
			printf("Warning: assuming that the map be generated by Imod in perpendicular mode!\n Flipping the values read on the header for the y and z axes.\n");
		unsigned long itmp = full_vol->z;
		full_vol->z = full_vol->y;
		full_vol->y = itmp;
	}
	
	vol_origin.x = 0.5 * ( full_vol->x - 1.0 );
	vol_origin.y = 0.5 * ( full_vol->y - 1.0 );
	vol_origin.z = 0.5 * ( full_vol->z - 1.0 );
	if ( imod_parfile && imd_tpars->setshift) {
		vol_origin.x += imd_tpars->shift_x;
		vol_origin.z += imd_tpars->shift_z;
	}

	if ( vol_type == VALL || vol_type == VMAXSPHERE ) {
		volut = shape3d_maxinit( volut, full_vol, vol_type );
	} else
		volut = shape3d_init( volut, vol_type, ox-1, oy-1, oz-1, sx, sy, sz, 0);
		
	if ( ivol_type != VNONE )
		volut = shape3d_init( volut, ivol_type, iox-1, ioy-1, ioz-1, isx, isy, isz, 1);  

	if(shape3d_check(full_vol,volut)<0) exit(-1);
	
	kill_img(full_vol);

	shape3d_taper_init(volut, 0); 

	if ( verbose & VERB_PROCESS )
		printf("Reading tilt angles file %s\n",tlt_file);
	tlt_angs = tlt_load_tilt_angles(tlt_file,&nangs);

	if ( verbose & VERB_PROCESS )
		printf("Loaded %d tilt angles\n",nangs);

	// check consistency between angles and projections
	b = io_read_image(refproj_file, 0, -1);

	if( nangs != (int ) ((b->n==1&&b->z>1)?b->z:b->n)) {
		fprintf(stderr,"Error: number of tilt angles in %s and number of projections in %s are not consistant!\n",
			tlt_file, refproj_file);
		exit(-1);
	}

	np = nangs;

	// initialize resolution 
	inloo3d = res_nloo3d_init(b, res_thr);

	if (imod_parfile && res==0.)  {
		res =  b->ux / imd_tilt_getresolutionlimit(imd_tpars);
		if ( verbose & VERB_PROCESS )
			printf("\nResolution limit set to %f angstroms\n",res);
	}
		

	kill_img(b);
	
	// initialize tilt views
	theta0 = xtilt;//*PI/180.0;
	phi0 = 0.5*M_PI;
	psi0 = -0.5*M_PI;
	tlt0_view = view_from_euler(psi0, theta0, phi0);

	nviews = nangs;

	tlt_views = tlt_views_from_angles(nviews,tlt0_view,tlt_angs);


	// initialize the angular resolution file
	if (out_angres_file) {
		fdar = fopen(out_angres_file,"w");
		fprintf(fdar,"n\ttheta");
		for (int i = 0; i<nrt; i++)
			fprintf(fdar,"\tNLOO2D(%3.1f)",res_thr[i]);
		fprintf(fdar,"\n");
	}

	if (imod_parfile) bfree(imd_tpars,sizeof(Imod_tilt));

//////////////////////////////////////////////////
// Loop evaluating the NLOO2D for each projection
//////////////////////////////////////////////////

	if ( verbose & VERB_LABEL )
		printf("Starting loop over projections\n");

	for ( int it = 0; it < np; it++) {

		if ( it%tusamp ) continue;

		if ( verbose & VERB_FULL )
			printf("Iteration # %d of %d\n",it+1, np);

		// check if projection to be excluded
		if ( is_inlist(it+1, xcld_list, nxl) ) continue;

///////////////////////////////////////////////////////////////////
// loading reprojection generated from volume with missing tilt(s)
///////////////////////////////////////////////////////////////////
		if ( verbose & VERB_DEBUG )
			printf("(DEBUG) Loading reprojection generated from partial reconstruction\n");


		bm = io_read_image(missproj_file, 1, it);
		// set user defined parameters and determine resolution
		bm->image[0].ox = 0.5 * ( bm->x - 1.0 );
		bm->image[0].oy = 0.5 * ( bm->y - 1.0 );
		bm->image[0].oz = 0.;
		if ( res > 0 )
			bm->resolution = res;
		if ( sampling.x*sampling.y*sampling.z > 0 ) {
			bm->ux = sampling.x;
			bm->uy = sampling.y;
			bm->uz = 0.;
		}
		miss_proj = proj_init(1);
		proj_cpy_img_sett(miss_proj, bm);
		proj_putimage(miss_proj, bm, 0, 0);
		proj_putview(miss_proj, tlt_views[it], 0);
		
		proj_init_footprint(miss_proj, vol_origin, volut, taper);
		proj_stats(miss_proj, bground_type);
		proj_mask(miss_proj);
	
///////////////////////////////////////////////////////////////////
// loading reprojection generated from original volume
///////////////////////////////////////////////////////////////////
		if ( verbose & VERB_DEBUG )
			printf("(DEBUG) Loading reprojection generated from original reconstruction\n");


		bf = io_read_image(fullproj_file, 1, it);
		// set user defined parameters and determine resolution
		bf->image[0].ox = 0.5 * ( bf->x - 1.0 );
		bf->image[0].oy = 0.5 * ( bf->y - 1.0 );
		bf->image[0].oz = 0.;
		if ( res > 0 )
			bf->resolution = res;
		if ( sampling.x*sampling.y*sampling.z > 0 ) {
			bf->ux = sampling.x;
			bf->uy = sampling.y;
			bf->uz = 0.;
		}
		full_proj = proj_init(1);
		proj_cpy_img_sett(full_proj, bf);
		proj_putimage(full_proj, bf, 0, 0);
		proj_putview(full_proj, tlt_views[it], 0);
		
		proj_copy_footprint(full_proj, miss_proj);
		proj_stats(full_proj, bground_type);
		proj_mask(full_proj);
	
///////////////////////////////////////////////////////////////////
// loading input projection 
///////////////////////////////////////////////////////////////////
		if ( verbose & VERB_DEBUG )
			printf("(DEBUG) Loading input projection\n");


		br = io_read_image(refproj_file, 1, it);
		// set user defined parameters and determine resolution
		br->image[0].ox = 0.5 * ( br->x - 1.0 );
		br->image[0].oy = 0.5 * ( br->y - 1.0 );
		br->image[0].oz = 0.;
		if ( res > 0 )
			br->resolution = res;
		if ( sampling.x*sampling.y*sampling.z > 0 ) {
			br->ux = sampling.x;
			br->uy = sampling.y;
			br->uz = 0.;
		}
		ref_proj = proj_init(1);
		proj_cpy_img_sett(ref_proj, br);
		proj_putimage(ref_proj, br, 0, 0);
		proj_putview(ref_proj, tlt_views[it], 0);
		
		proj_copy_footprint(ref_proj, miss_proj);
		proj_stats(ref_proj, bground_type);
		proj_mask(ref_proj);
	
///////////////////////////////////////////////////////////////////
//   rescale projections and evaluate NLOO2D resolution
///////////////////////////////////////////////////////////////////
		if(rescale_type==0) {
			proj_rescale_to_avg_std(miss_proj, (full_proj->img[0])->avg, (full_proj->img[0])->std, &((full_proj->img[0])->image[0].background));
			proj_rescale_to_avg_std(ref_proj, (full_proj->img[0])->avg, (full_proj->img[0])->std, &((full_proj->img[0])->image[0].background));
		} else if(rescale_type==1) {
			proj_rescale_linregression(miss_proj, full_proj);
			proj_rescale_linregression(ref_proj, full_proj);
		}

		res_est = res_nloo2d_estimate(it+1, tlt_angs[it]*180.0/M_PI, ref_proj->img[0], miss_proj->img[0],
				full_proj->img[0], bin_size, (Bimage *) NULL, out_nloo2d_file,
				res_thr, inloo3d);

		if (out_angres_file) {
			fprintf(fdar,"%d\t%5.2f",it+1, tlt_angs[it]*180.0/M_PI);
			for (int i = 0; i<nrt; i++)
				fprintf(fdar,"\t%8.3f",res_est[i]);
			fprintf(fdar,"\n");
		}
		
		if ( verbose & VERB_LABEL ) {
			printf("Resolution estimate:\n");
			printf("n\ttheta");
			for (int i = 0; i<nrt; i++)
				printf("\tNLOO2D(%3.1f)",res_thr[i]);
			printf("\n");

			printf("%d\t%5.2f",it+1, tlt_angs[it]*180.0/M_PI);
			for (int j = 0; j<nrt; j++)
				printf("\t%8.3f",res_est[j]);
			printf("\n");
		}

		bfree(res_est, RES_NTHRESHOLDS*sizeof(float));	// Trash resolution estimates
	

		proj_kill(ref_proj);
		proj_kill(full_proj);
		proj_kill(miss_proj);
		
		fflush( (FILE *) NULL);
	}

	if (out_angres_file)
		fclose(fdar);

	res_nloo3d_estimate(inloo3d, out_nloo3d_file);


	// deallocation
	res_nloo3d_kill(inloo3d);

	bfree(tlt_views,nviews*sizeof(View));	
	bfree(tlt_angs,nangs*sizeof(float));	
	bfree_string(tlt_file);
	shape3d_kill(volut);
	if ( out_nloo3d ) bfree_string(out_nloo3d_file);
	if ( out_angres ) bfree_string(out_angres_file);
	if ( out_nloo2d ) bfree_string(out_nloo2d_file);	
	bfree_string(out_pfx_file);
	bfree_string(refproj_file);
	bfree_string(fullproj_file);
	bfree_string(missproj_file);
	if (proj_prefix_file) bfree_string(proj_prefix_file);
	bfree_string(in_vol_file);
	bfree_string(imod_parfile);
	if (set_xcld) bfree_string(xcld_str);

	if ( verbose ) {
		printf("-----------------------------------------------\n");
		printf("       et-nloo concluded successfully!\n");
		printf("-----------------------------------------------\n");
	}
	return(0);
}

// check if given number is in the list
int is_inlist(int idx, int* xcld_list, int nxl)
{
	for (int i = 0; i<nxl; i++)
		if (idx == xcld_list[i]) return(1);
		
	return(0);
}
